import "utils/pack/pack128" as pack128
import "utils/pack/nonStrictUnpack256.zok" as unpack256
import "../common/packing/unpack2x128To256x1" as unpack2x128To256x1

import "../common/hashes/sha256/sha256of2x128.zok" as sha256of2x128
import "../common/hashes/sha256/sha256of10x128.zok" as sha256of10x128

import "../common/ecc/edwards-compress.zok" as edwardsCompress
import "../common/ecc/verify-eddsa.zok" as verifyEddsa
import "ecc/babyjubjubParams.code" as context

import "../common/merkle-tree/calc-root-from-siblingPath-sha256-height4.zok" as calculateRoot

struct EdDSASignature {
  field[2] R
  field S
}


//structure of agreement:
// { inputs {}, commitments [linked list], root, calldata}

struct AgreementInputs {
  field[2] publicKeyOfBuyer
  field[2] publicKeyOfSupplier
  field[2] erc20ContractAddress
  EdDSASignature buyerSignature
  EdDSASignature supplierSignature
  field[2] nullifier // we can choose the nullifier to always be a constant (0) or an input
}

struct AgreementCommitment {
  field[2] value
  field[2] salt
  field index
  field[4] siblingPath
}

// maintain all agrements' references as a linked list in the Shield.sol
// calldata is the agreement's raw data: name, description, token symbol attached, etc.
struct Agreement {
  AgreementInputs inputs
  AgreementCommitment newCommitment
  field oldCommitmentValue
  field calldata
}
// determine max upper bound of a struct in DSL
// TODO: explore how rust manages dynamic expansion of 
// field to other data types: structs, arrays, etc.

def main(field publicInputHash, private field[2] root, private Agreement agreementData) -> ():
  // compressing public keys of type point (X,Y)
  field[256] publicKeyOfBuyerCompressed = edwardsCompress(agreementData.inputs.publicKeyOfBuyer)
  field[256] publicKeyOfSupplierCompressed = edwardsCompress(agreementData.inputs.publicKeyOfSupplier)

  // formatting public keys to pass as 128 bit field elements to sha256
  // TODO: find a way of not using the constraint-heavy 'pack' function.
  field publicKeyOfBuyerCompressed1 = pack128(publicKeyOfBuyerCompressed[0..128])
  field publicKeyOfBuyerCompressed2 = pack128(publicKeyOfBuyerCompressed[128..256])
  field publicKeyOfSupplierCompressed1 = pack128(publicKeyOfSupplierCompressed[0..128])
  field publicKeyOfSupplierCompressed2 = pack128(publicKeyOfSupplierCompressed[128..256])


  // Proof that the Buyer is indeed the Buyer for this Agreement (by recalculating the Agreement commitment):
  agreementCommitmentBits = unpack2x128To256x1(agreementData.newCommitment.value)
  // one could choose sha or pedersen or poseidon, etc.

  // first step: hash all inputs, raw data and salt
  // second step: hash from 1, nullifier, oldCommitmentValue
  // third step: calculate root
  // fourth step: hash (root, hash from 2)
  // final hash is the publicInputHash
  agreementCommitmentBits = sha256of12x128([publicKeyOfBuyerCompressed1, 
                                                 publicKeyOfBuyerCompressed2, 
                                                 publicKeyOfSupplierCompressed1, 
                                                 publicKeyOfSupplierCompressed2,
                                                 calldata,
                                                 salt])

  agreementNullifierBits = sha256of3x128([agreementData.newCommitment.value,
                                          agreementData.inputs.nullifier,
                                          agreementData.oldCommitmentValue
                                          ])
  
  calculatedRoot = calculateRoot(agreementData.newCommitment.siblingPath, 
                                agreementData.newCommitment.value, 
                                agreementData.newCommitment.index)

  inputAgreementCommitment = unpack2x128To256x1(agreementData.newCommitment.value);
  agreementCommitmentBits == inputAgreementCommitment

  // VERIFY SIGNATURES
  context = context()

  field isVerifiedBuyer = verifyEddsa(agreementData.inputs.buyerSignature.R, agreementData.inputs.buyerSignature.S, agreementData.inputs.publicKeyOfBuyer, agreementCommitmentBits, context)
  field isVerifiedSupplier = verifyEddsa(agreementData.inputs.supplierSignature.R,  agreementData.inputs.supplierSignature.S, agreementData.inputs.publicKeyOfSupplier, agreementCommitmentBits, context)
  isVerifiedBuyer == 1
  isVerifiedSupplier == 1

  // Check the publicInputHash:
  publicInputHashBits = unpack256(publicInputHash)
  publicInputHashBitsCheck = sha256of2x128([calculatedRoot,
                                            agreementNullifierBits])
  publicInputHashBits[8..256] == publicInputHashBitsCheck[8..256]

  return
